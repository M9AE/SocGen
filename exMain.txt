// This project has as purpose to train the people to the games proposed for the Société Générale recruitment.
// It has as goal to spread qualifications for these tests that the author estimates non-representative.

#include <cstdlib> // Pour srand() et rand()
#include <ctime>   // Pour time()
#include <chrono>
#include <iostream>
#include <random>

#include "Pops.h"
#include "Menu.h"
#include "Symetriques.h"

#include <Imagine/Graphics.h>
using namespace Imagine;

const int N = 35;
const int w = 800, h = 300, dh=80;
const int nb_rounds = 1;

Color background_blue = Color(22, 155, 227);




int main() {
    // ==================  INITIALISATION  ================== //
    srand(time(0)); // Initialise le générateur de nombres aléatoires
    enableMouseTracking(true);
    openWindow(w,h+dh); // Fenêtre graphique
    setBackGround(background_blue);

    std::vector<Pop> popList; // Liste des Pops cliquables
    listPointInitialize(popList, N, 38, w, h, false);

    std::vector<int> selectedPops;
    initializeIntList(nb_rounds, int(popList.size()), selectedPops);

    // =======================  MENU  ======================= //
    // A mettre en commentaires
    displayMenu(w);
    int x_clic, y_clic, index, zone=-1;

/*
    display(0,0,srcPath("passage0.png"));
    for (int i=0; i<5; i++) {
        x_clic=-1, y_clic=-1;
        while (x_clic==-1 && y_clic==-1) {
            std::cout << "Etape 1" << std::endl;
            getMouse(x_clic, y_clic);
            milliSleep(1000);

            std::cout << "Etape 2" << std::endl;
            index = getIndex(x_clic,y_clic);
            std::cout << "  index=" << index << std::endl;
            milliSleep(1000);

            std::cout << "Etape 3" << std::endl;
            zone = updatePassage(x_clic, y_clic, index);
            std::cout << "  " << zone << std::endl;
            milliSleep(1000);

            std::cout << "Etape 4" << std::endl;
            getMouse(x_clic, y_clic);
            milliSleep(1000);

            std::cout << std::endl;
            std::cout << std::endl;
            std::cout << std::endl;
            std::cout << std::endl;
        }
    }
*/

/*
    for (int i=0; i<5; i++) {
        x_clic=-1, y_clic=-1;
        displayMenu();

        while (x_clic==-1 && y_clic==-1) {
            getMouse(x_clic, y_clic);
            index = getIndex(x_clic,y_clic);
            std::cout << "  index : " << index << std::endl;

            zone = updatePassage(index);
            std::cout << "  zone : " << zone << std::endl;

            std::cout << std::endl;
            std::cout << std::endl;
            std::cout << std::endl;
            std::cout << std::endl;
        }
    }
*/


    while (zone == -1) {
        getMouse(x_clic, y_clic);
        index = getIndex(x_clic,y_clic);
        std::cout << "  index : " << index << std::endl;

        if (!developInfos(w,h,dh,x_clic,y_clic)) {
            zone = updatePassage(w, h, dh, index);
            std::cout << "  zone : " << zone << std::endl;
        }
    }

    // =======================  JEUX  ======================== //

    if (index == 0) {  //  JEU DES POPS SIMPLES
        const int N1=10, N2=5;
        const double p=0.5, p2=0.5;
        simplePopsGame(popList, selectedPops, w, h, dh, nb_rounds);
    }

    if (index == 1) {  //  JEU DES SYMETRIQUES
        const int N1=10, N2=5;
        const double p=0.5, p2=0.5;
        JeuDesSymetriques(popList, selectedPops, w, h, dh, N1, N2, p, p2, nb_rounds);
    }


    // =======================  FIN  ======================== //
    endGraphics();
    return 0;
}

/*/ TEST SYMETRIQUE
bool getPositionAndClickStatus(int& x, int& y, bool& clic) {
    Event ev;
    getEvent(50, ev); // Petit timeout
    clic = false;
    switch (ev.type) {
    case EVT_BUT_ON:
        x = ev.pix.x();
        y = ev.pix.y();
        clic = true;
        return true;
    default:
        return false;
    }
}

int main() {
    enableMouseTracking(true);

    int x = 0, y = 0; // Position initiale de la souris
    bool clic = false; // État initial du clic

    // Initialiser le système de fenêtrage
    openWindow(500, 500);

    // Boucle principale pour tester la fonction
    double t0 = time(0);
    double delta_t = 10;
    std::cout << t0 << std::endl;
    while (time(0)-t0<delta_t) {
        getPositionAndClickStatus(x, y, clic);
        // Affichage de la position de la souris et de l'état du clic
        if (clic) {
            std::cout << " - Clic détecté // ";
            std::cout << time(0) << " // ";
            std::cout << time(0)-t0 << " // ";
            std::cout << "Position: (" << x << ", " << y << ")";
            std::cout << std::endl;
        }
        milliSleep(20);
    }

    return 0;
}*/

/*/ TEST MENU
bool getPositionAndClickStatus(int& x, int& y, bool& clic) {
    Event ev;
    getEvent(0, ev); // Sans timeout
    x = ev.pix.x();
    y = ev.pix.y();
    clic = false;

    switch (ev.type) {
    case EVT_MOTION:
        return true;

    case EVT_BUT_ON:
        clic = true;
        return true;

    default:
        return false;
    }
}

int main() {
    enableMouseTracking(true);

    int x = 0, y = 0; // Position initiale de la souris
    bool clic = false; // État initial du clic

    // Initialiser le système de fenêtrage
    openWindow(500, 500);

    // Boucle principale pour tester la fonction

    while (true) {
        getPositionAndClickStatus(x, y, clic);
        // Affichage de la position de la souris et de l'état du clic
        std::cout << "Position: (" << x << ", " << y << ")";
        if (clic) {
            std::cout << " - Clic détecté";
        }
        std::cout << std::endl;
        milliSleep(20);
    }

    return 0;
}*/
